> 애플리케이션 개발자가 DB 를 처음부터 만들지는 않지만, 해당 애플리케이션의 작업 유형에 맞는 엔진을 선택하려면 내부적으로 어떻게 수행되는지 알아야한다.

### 데이터베이스를 강력하게 만드는 데이터 구조

일반적으로 데이터를 어떤 파일에 계속 append 하는 방식이 DB 엔진의 기본이다.  
이렇게 되면, 매번 데이터를 찾을때마다 전체를 스캔해야 하기 때문에 검색 비용이 O(n)이 된다.  
그래서 특정 키 값을 효율적으로 찾기 위해 색인구조를 사용한다.

색인구조는 일반적으로 "어떤 부가적인 메타데이터를 유지한다."는 구조이다.

#### 1\. 해시 색인

키의 갯수가 적고, 키 당 데이터를 읽는 횟수가 많을 경우 적합한 색인법  
키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지한다.  
바이트 오프셋이란 값을 바로 찾을 수 있는 위치.

새로운 키를 삽입하거나, 키를 갱신할 때 모두 해시맵을 갱신해야한다.  
값을 조회할때는 해시맵을 사용해 데이터 파일에서 오프셋을 찾아 위치를 구하고 값을 읽는다.

추가 전용 로그  
키에 대한 값을 갱신하지 않고 계속해서 추가함 -> 디스크의 저장공간이 모자를 수 있다.  
컴팩션 + 병합 과정을 거쳐 디스크 공간을 확보한다.

컴팩션 : 중복된 키를 버리고, 각 키의 최신 갱신 값만 유지한다.

추가 전용 로그에서 컴팩션 + 병합 구현시 고려해야할 사항

-   파일 형식 : 바이너리로 데이터를 저장해야 빠르다.
-   레코드 삭제 : 데이터 삭제시에는 툼스톤이라는 특수 레코드를 추가한다. 세그먼트 병합시 툼스톤이 있으면 삭제된 키의 이전 값을 무시한다.
-   고장 복구 : DB 재시작시 인메모리 해시맵은 소실됨으로 빠르게 복구 할 수 있는 방법을 생각해야한다. (디스크에 스냅샷을 저장)
-   부분적으로 레코드 쓰기 : 로그에 데이터를 추가하는 도중에 죽을 수 있으므로, 로그 저장시 체크섬을 저장해야한다.
-   동시성 제어 : 데이터 파일 세그먼트는 추가전용이거나, 불변이므로 다중스레드로 동시에 읽을 수 있다.

그렇다면, 처음부터 특정 키를 정해진 자리에 저장하고, 갱신하는 방법을 쓰면 더 좋지 않을까??

-   추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠르다.
-   세그먼트 파일이 추가 전용이나 불변이며 동시성과 고장복구 측면에서 유리하다. 값을 덮어 쓰는 동안 유 가 죽을 경우 이전 값 부분과 새로운 값 부분을 포함한 파일을 남겨두기 때문이다.
-   오래된 세그먼트 병합은 오래된 데이터 파일 조각화 문제를 피할 수 있게 한다.

해시 색인의 제약 사항

-   키가 너무 많으면 메모리에 올릴 수 없다.
-   해시테이블은 범위 질의에 효율적이지 않다. 개별키 조회 해야한다.

#### 2\. SS 테이블과 LSM 트리

SS(Sorted String) Table  
키로 정렬된 테이블

해시 색인을 가진 로그세그먼트와 비교해서 장점

1.  데이터가 키로 정렬되어 있기 때문에 세그먼트 병합이 효율적이다.(병합정렬)
2.  모든 데이터를 캐시에 유지하지 않아도, 메모리에 있는 색인만을 가지고 찾으려는 데이터에 접근 할 수 있다.  
    \-> 메모리에 인덱스 되어있는 데이터를 따라 대략적인 위치를 잡고 스캔한다.
3.  메모리에 있는 희소 색인이 가르키는 데이터를 기준으로 데이터를 압축해서 디스크에 저장할 수 있다.

#### 2-1. SS 테이블 생성과 유지

데이터를 키로 정렬하려면?  
레드블랙트리, AVL 트리를 이용하면 임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있다.


Red-Black Tree
https://zeddios.tistory.com/237


Red/Black Tree Visualization
www.cs.usfca.edu


저장소 엔진은 아래처럼 만들 수 있다.

1.  쓰기가 들어오면 균형 트리에 추가, 이 인메모리 트리는 멤테이블 이라고 한다.
2.  멤테이블이 임계치 이상 넘어가면 데이터를 SS테이블 파일로 디스크에 기록한다.(이미 키로 정렬되어있어 빠름)
3.  읽기 요청이 들어오면 멤테이블에서 먼저 찾고 디스크 상의 가장 최신 세그먼트 순으로 찾는다.
4.  백그라운드에서 병합과 컴팩션 과정을 수행한다.

데이터 베이스가 고장나면 아직 디스크로 기록되지 않은 멤테이블 최신 쓰기가 손실될 수 있다.  
\-> 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크상에 유지해야한다.

#### 2-2. SS 테이블에서 LSM 트리 만들기

  
Log-structured Merge-Tree  
정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라고 한다.  
Ex) 어떤 단어가 언급된 문서를 찾기 위해 단어를 키, 단어가 언급된 문서 ID를 값으로 갖도록 SS테이블에 저장하고 백그라운드에서 병합한다.  
  
참고자료 :

LSM Tree
https://www.secmem.org/blog/2021/02/21/lsm-tree/

  
성능 최적화 전략

1) 존재하지 않는 키를 찾는경우 가장 오래된 세그먼트까지 거슬러 올라가므로 매우 느릴 수 있다.  
존재하지 않는 키를 알려주는 데이터구조인 블룸 필터를 사용해 디스크 읽기를 절약한다.


Bloom Filter 자료구조
https://taeguk2.blogspot.com/2019/05/bloom-filter.html

2) SS 테이블을 컴팩션+병합하는 시기를 결정

크기 계층 : 상대적으로 새롭고 작은 SS테이블을 오래되고 큰 SS테이블에 연이어 병합  
레벨 컴팩션 : 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하여 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용한다.

LSM트리의 기본개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것이다.  
데이터가 이미 정렬되어 있기 때문에 범위질의도 효율적으로 수행할 수 있다.

#### 3\. B트리

시작하기 전에..

디스크에서 부터 생각해보기
https://velog.io/@seanlion/btree

가장 널리 사용되는 색인 구조  
LSM 색인은 데이터베이스를 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록한다.  
반면 B트리는 전통적으로 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기 또는 쓰기를 한다.

각 페이지는 주소나 위치를 이용해 식별할 수 있으며, 한 페이지에서 다른 페이지를 참조할 수 있다.  
상위 페이지일수록 큰 범위의 참조를 가지고 있으며, 하위 페이지로 갈수록 참조가 세분화 된다. 최종적으로 개별키를 포함하는 리프 페이지에 도달하고 이 페이지는 각 키값을 포함하거나 값을 찾을 수 있는 참조를 가진다.

기존 값을 갱신하려면, 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다.  
새로운 키를 추가하려면 해당 값 범위 페이지를 찾아 그 페이지에 추가하는데, 만약 여유 공간이 없으면 그 페이지를 둘로 나누고 상위 페이지에서 나눠진 범위의 하위페이지들을 찾을 수 있게 참조를 갱신한다.

#### 3-1. 신뢰할 수 있는 B트리 만들기

LSM 색인은 새로운 데이터를 파일에 계속 추가만 하지만, B트리는 디스크상의 페이지에 덮어 쓴다.  
새로운 데이터를 추가하는 과정에서 위처럼 페이지를 두개로 나누고 상위 페이지의 참조를 갱신하는 작업을 하다가 중간에 DB가 고장나면 색인이 훼손될 수 있다.(고아 페이지 발생)

\-> 트리 페이지에 변경된 내용을 적용하기 전에 모든 B트리의 변경사항을 기록하는 redo로그를 추가해 복구 가능하고록 한다.

다중 스레드가 동시에 B트리에 접근한다면 latch등을 사용해 데이터를 보호해야한다.

#### 3-2. B 트리 최적화

페이지에 전체 키를 저장하는게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다.  
특히 트리 내부 페이지에서 키가 키 범위 사이의 경계 역할을 하는데 충분한 정보만 제공하면 된다. 페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기계수를 얻는다.

그러면 트리의 깊이 수준을 낮출 수 있다. 트리가 옆으로 넓어진다? -> B+ 트리

#### 3-3. B 트리와 LSM 트리 비교

LSM트리는 쓰기에서 더 빠르고, B트리는 읽기에서 더 빠르다.  
(LSM트리는 읽기시 각 컴팩션 단계에 있는 여러 데이터구조와 SS테이블을 확인해야 하기 때문)

LSM 트리의 장점  
쓰기 증폭(한번의 쓰기 요청으로 디스크에 여러번 쓰기를 야기하는 효과)이 더 낮고, 트리에서 여러 페이지를 덮어쓰는것이 아니라 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문 쓰기 처리량이 더 높다.  
단점  
컴팩션과정이 실제 읽기와 쓰기의 성능에 영향을 준다.

B트리의 장점  
각 키가 색인의 한곳에만 존재한다.  
단점  
파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다.  
  
DB 관점에서 B+ 트리 장점

   
1\. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다.하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)  

2\. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다. 

출처 : 
https://potatoggg.tistory.com/174

B+ Tree Visualization
www.cs.usfca.edu


실제 DB 관점 이미지
https://ju-hy.tistory.com/106


#### 4\. 기타 색인 구조

기본키 색인 - 하나의 데이터를 고유하게 식별할 수 있다.  
보조 색인 - 효율적인 조인을 수행, 키가 고유하지 않다.

예를들어 철자가 틀린 단어와 같이 유사한 키에 대한 검색은 어떻게 해야할까?  
\-> 작은 인메모리 색인을 두고 트라이 자료구조처럼 한 철자마다 다른 키로 색인 시켜놓고 참조한다.

### 트랜잭션 처리나 분석?

ACID(Atomicity, Consistency, Isolation, Durability)  
원자성, 일관성, 격리성, 지속성

데이터 트랜잭션 처리는 클라이언트가 지연시간이 낮은 읽기와 쓰기를 가능하게 하는 것  
데이터 분석은 많은 수의 레코드를 스캔해 레코드당 일부 칼럼만 읽어 집계 통계를 계산하는 것

분석용 스키마

-   별모양 스키마 : 실제 행동을 기록하는 fact table과 fact table이 참조하는 다른 table(dimension table)로 구성  
    사실 테이블의 각 로우는 이벤트를 나타내고, 차원은 이벤트의 속성인 누가, 언제, 어디서, 무엇을, 어떻게, 왜 를 나타낸다.

칼럼 지향 저장소  
모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장한다.  
각 칼럼을 개별 파일에 저장하면, 질의에 사용되는 칼럼만 읽고 구분 분석하면 된다.  
모든 개별 파일이 같은 순서이기 때문에 전체값을 다시 모으려면 개별 칼럼파일의 23번째 항목을 가져와 합치면 된다.

구체화 뷰  
동일한 집계를 다양한 집계에서 사용한다면, 질의가 자주 사용하는 count, sum값을 캐시해둘 수 있다.  
이미 우리가 사용하는 표준뷰(가상뷰)와 차이점은 구체화 뷰는 디스크에 기록된 질의 결과의 실제 복사본이이지만  
표준뷰는 단지 질의를 작성하는 단축키일 뿐이다.  
원본 데이터 갱신시 구체화뷰도 갱신을 해야하는데, 이 비용이 비싸기 때문에 트랜잭션 처리에서는 잘 사용하지않고, 분석 처리에서 많이 사용한다.

데이터 큐브  
구체화 뷰를 다차원으로 구성해놓은것  
특정 칼럼들을 결합해서 원하는 결과를 미리 쿼리해서 저장해놓고 사용한다.  
특정 질의를 효과적으로 미리 계산했기 때문에 해당 질의를 수행할때 매우 빠르다.  
단점은 원시 데이터를 질의하는 것과 동일한 유연성이 없다는 것이다.  
(차원에 포함되지 않은 컬럼으로는 질의할 수 없음)

---

정리  
OLTP  
대량의 요청을 받을 수 있고 대부분의 질의가 작은수의 레코드만 다룬다.  
애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 ㅇ요청한 키와 데이터를 찾기위해 색인을 사용한다.

OLAP  
OLTP 보다 훨씬 적은 수의 질의를 다루지만 각 질의는 대개 매우 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스캔해야한다.
