# 08. 분산 시스템의 골칫거리

결국 엔지니어로서의 우리의 임무는 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축하는 것이다. (p274)

- 네트워크 관련 문제
- 시계 및 타이밍 문제

## 결함과 부분 장애

분산 시스템에서는 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것도 무리가 아니다. 이를 **부분 장애**라고 한다. (p275)

### 클라우드 컴퓨팅과 슈퍼컴퓨팅

클라우드 컴퓨팅 (cf. 슈퍼컴퓨팅)

- 언제라도 사용자에게 지연 시간이 낮은 서비스를 제공해야 함 (온라인)
- 규모의 경제 덕에 낮은 비용으로 동일한 성능을 제공하지만 실패율도 높음
- IP와 이더넷을 기반으로 하며 높은 양단 대역폭을 제공하기 위해 클로스 토폴로지로 연결돼 있음
- 시스템이 커질수록 구성 요소 중 하나가 고장날 가능성도 높아짐
- 따라서 항상 뭔가 고장난 상태라고 가정하는 게 합리적
- 지리적으로 분산된 배포를 위해 인터넷 사용 (로컬 네트워크에 비해 느리고 신뢰성도 떨어짐)

분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다. 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다. (p276)

발생 가능성이 상당히 낮을지라도 생길 수 있는 결함을 광범위하게 고려하고 테스트 환경에서 인위적으로 이런 상황을 만들어서 어떤 일이 생기는지 보는 게 중요하다. (p277)

## 신뢰성 없는 네트워크

인터넷과 데이터센터 내부 네트워크 대부분은 **비동기 패킷 네트워크**다. 이런 종류의 네트워크에서 노드는 다른 노드로 메시지(패킷)를 보낼 수 있지만 네트워크는 메시지가 언제 도착할지 혹은 메시지가 도착하기는 할 것인지 보장하지 않는다. (p278)

### 현실의 네트워크 결함

네트워크 결함이 드물더라도 결함이 일어날 수 있다는 사실은 여러분의 소프트웨어가 이를 처리할 수 있어야 한다는 뜻이다. (p280)

반드시 네트워크 결함을 견뎌내도록(tolerating) 처리할 필요는 없다. 그러나 소프트웨어가 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다. (p280)

### 결함 감지

결함 있는 노드를 자동으로 감지할 수 있어야 함

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 함
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 함

명시적인 피드백을 받을 수도 있음

- 목적지 포트에서 수신 대기하는 프로세스가 없다면 운영체제가 RST나 FIN 패킷을 응답으로 보내서 TCP 연결을 닫거나 거부
- 스크립트로 다른 노드에게 프로세스가 죽었다고 알려서 다른 노드가 타임아웃이 만료되기를 기다릴 필요 없이 빠르게 역할을 넘겨받을 수 있게 함
- 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근할 수 있으면 질의를 보내 하드웨어 수준의 링크 장애를 감지할 수 있음
- 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답할 수도 있음

아무 응답도 받지 못하는 경우, 몇 번 재시도를 해 보고 타임아웃이 만료되기를 기다렸다가 타임아웃 내에 응답을 받지 못하면 마침내 노드가 죽었다고 선얼할 수 있음

### 타임아웃과 기약 없는 지연

- 타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어짐
- 타임아웃이 짧으면 결함을 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아짐

타임아웃은 얼마나 길어야 할까?

- 모든 패킷은 어떤 시간 d 내에 전소오디거나 손실되지만 전송 시간이 결코 d보다 걸리지 않는다.
- 장애가 나지 않는 노드는 항상 요청을 r 시간 내에 처리한다.

위 조건이 보장된다면 합리적인 타임아웃은 2d + r 이지만, 우리가 사용하는 시스템은 대부분 이 중 어떤 것도 보장하지 않는다.

### 네트워크 혼잡과 큐 대기

다음과 같은 상황에서 큐 대기가 발생할 수 있다.

- 여러 다른 노드가 동시에 같은 목적지로 패킷을 보내려고 하는 경우 (네트워크 혼잡)
- 패킷이 목적지 장비에 도착했을 때 모든 CPU 코어가 바쁜 상태인 경우
- 가상 환경에서 실행되는 운영체제에서 다른 가상 장비가 CPU 코어를 사용하는 동안 지연이 발생하는 경우
- TCP의 흐름 제어(flow control)에 의해 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 송신율이 제한되는 경우
- TCP에서 패킷 손실 및 재전송에 의한 지연이 발생하는 경우 (cf. UDP)

네트워크 지연의 변동성에 영향을 주는 요인은 다양하다.

- 여러 소비자가 자원을 공유하는 공개 클라우드 환경에서 자원을 많이 사용하는 누군가(시끄러운 이웃)가 가까이 있는 경우

지연의 변동성이 얼마나 되는지 알아내려면 긴 기간에 여러 장비에 걸쳐서 네트워크 왕복 시간의 분포를 측정해야 한다. (실험적으로 타임아웃을 선택해야 한다.)

더 좋은 방법은 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시고나과 그들의 변동성(지터)을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 하는 것이다.

### 동기 네트워크 대 비동기 네트워크

동기 네트워크의 예 - 전화

- 회선(circuit)은 만들어져 있는 동안 다른 누구도 사용할 수 없는 고정된 양의 예약된 대역폭
- 네트워크의 다음 홉(hop)에 통화당 16비트의 공간이 이미 할당됐기 때문에 큐 대기 문제를 겪지 않음
- 왕복 시간의 최대치를 보장할 수 있음 (제한 있는 지연)

비동기 네트워크의 예 - TCP 연결

- 가용한 네트워크 대역폭을 기회주의적으로 사용
- 이더넷과 IP는 큐 대기의 영향을 받는 패킷 교환 프로토콜(cf. 회선 교환)
- 기약 없는 지연 발생 가능
- 순간적으로 몰리는 트래픽에 최적화 (네트워크 용량에 맞춰 데이터 전송률 동적 조절 가능)

따라서 우리의 시스템에서는 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 것이라고 가정해야 하며, 타임아웃에 올바른 값은 없으며 실험을 통해 결정해야 한다.

## 신뢰성 없는 시계

- 분산 시스템에서는 통신이 즉각적이지 않으므로 시간은 다루기 까다롭다.
- 게다가 네트워크에 있는 개별 장비는 자신의 시계를 갖고 있다. (보통 수정 발진기, quartz crystral oscillator)
- 시간을 도익화 하기 위해 가장 널리 쓰이는 메커니즘은 네트워크 시간 프로토콜(Network Time Protocol, NTP)로 서버 그룹에서 보고한 시간에 따라 컴퓨터 시계를 조정할 수 있게 한다.

### 단조 시계 대 일 기준 시계