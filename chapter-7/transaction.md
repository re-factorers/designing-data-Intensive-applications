## 07. 트랜잭션

데이터 시스템에서 발생할 수 있는 문제

DB 가 죽는다면? 네트워크가 끊긴다면?
동시에 데이터를 쓴다면?

트랜잭션은 이러한 문제를 단순화 할 수 있는 메커니즘
어느정도 잠재적 오류나 동시성을 보장해준다.(safety guarantee)

> 트랜잭션이란,
> 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.


1. 한 트랜잭션내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
2. 전체가 성공하거나 실패한다.-> 부분적 실패에 대해 고려할 필요가 없다.

### 애매 모호한 트랜잭션의 개념
#### ACID 의 의미
Atomicity

시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며, 그 중간 상태에는 머무를 수 없다.


원자성은 클라이언트가 쓰기 작업 몇 개를 실행하려고 하는데 그중 일부만 처리된 후 결함이 생기면 무슨일이 생기는지 설명한다.

여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료될 수 없다면, 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.

어보트됐다면 애플리케이션이 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도할 수 있다.


Consistency

어떤 불변식에 대해 트랜잭션의 모든 쓰기가 유효성을 보존한다면, 불변식이 항상 만족되어야 한다.

이 아이디어는 애플리케이션의 불변식 개념에 의존한다. 일관성을 유지하도록 트랜잭션을 올바르게 정의하는것은 애플리케이션의 책임이다.

일관성 달성을 위해 데이터베이스의 원자성, 격리성에 기댈 수 있지만, 데이터베이스만으로 해결되는것이 아니다.


Isolation

여러 클라이언트에서 동일한 데이터베이스 레코드에 접근하면 동시성 문제가 생긴다.(경쟁조건)

동시에 실행되는 트랜잭션은 서로 격리된다.

데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다.

Durability

트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않아야한다.

디스크에 쓰기, 원격 장비에 복제하기, 백업 등을 포함해 위험을 줄이려는 기법이 여러가지 있고 가능하면 모두 같이 사용해야한다.

#### 단일 객체 연산과 다중 객체 연산
ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술한다.
다중 객체 트랜잭션은 흥히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

격리성은 일관성이 깨지는 중간지점을 보는일(더티 리드)를 없애준다.
원자성은 요청의 일부가 실패하면 어보트하고 이미 수행된 요청을 롤백한다.

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야한다.

관계형에서는 TCP로 연결
어떤 특정 연결 내에서 BEGIN TRANSACTION ~ COMMIT 문 사이의 모든것은 같은 트랜잭션에 속하는것으로 여긴다.

비관계형에서는 연산을 묶는 방법이 없다
-> 다이나모 트랜잭션 조사해보기
어떤키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 db가 부분적으로 갱신될 수 있다.

#### 단일객체 쓰기

원자성은 history를 기록하는 crash recovery용 로그로 구현

격리성은 각 객체의 잠금을 통해 동시에 한 스레드만 접근할 수 있도록 구현할 수 있다.

일반적으로 트랜잭션이랑 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.

### 다중객체 트랜잭션의 필요성
외래키를 가지는 경우, 비정규화된 정보를 갱신하는 경우, index를 가지는 경우 한번에 여러 다른 객체에 쓰기 작업을 수행하게 되며 이를 트랜잭션으로 관리해야 한다.

오류와 어보트 처리

트랜잭션의 핵심기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.

오류 복구는 애플리케이션에 책임이 있다.

어보트 후 재시도는 몇가지 아쉬운 부분이 있다.
1. 커밋 성공을 알리는 도중 끊기면 두번 수행된다.
2. 리트라이 스톰 발생 가능
3. 재시도로 인해 부수효과가 발생할 수 있다.
   
   
### 완환된 격리 수준
https://bitcointalk.org/index.php?topic=499580

완화된 격리 수준
격리성(직렬성)을 완벽하게 지키려면 비용이 크므로 실무에서는 완화된 격리 수준을 제공한다.


#### 커밋 후 읽기
1. 커밋 후 읽기
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게된다.(더티 읽기 없음)
- 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다.(더티 쓰기 없음)

더티읽기 방지

더티 읽기 : 트랜잭션이 썼지만 커밋, 어보트 되지 않은 상태

반영되지 않은 데이터가 보이면 더티 읽기 라고 한다.

더티읽기 방지가 유용한 이유
- 부분적으로 갱신된 데이터가 노출될 경우 사용자가 혼란스러움
- 더티읽기를 허용하면 추후 롤백될 수 있는 데이터가 사용자에게 노출 될 수 있음

더티쓰기 방지

더티 쓰기 : 먼저 쓴 내용이 아직 커밋되지 않은 상태에서 나중에 실행된 쓰기가 커밋되지 않은 값을 덮어 쓰는것

보통 먼저 쓴 트랜잭션이 커밋될때까지 두번째 쓰기를 지연시킨다.

더티쓰기 방지가 유용한 이유 : 동시성 문제 회피!

#### 커밋 후 읽기 구현

가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.

#### 스냅숏 격리와 반복읽기
트랜잭션 커밋 시점에 데이터가 다르게 나오는 현상을 비반복 읽기, 읽기 스큐 라고 한다.
커밋 후 읽기 격리에서는 읽기 스큐가 허용된다.

주의! 백업이나 분석 질의 같이 한번에 큰 데이터를 질의하는 경우 일부는 과거 데이터, 일부는 신규 데이터를 가져 비일관적이게 된다.

스냅숏 격리를 적용하면,
각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다. 시작하는 시점 ~ 커밋 전까지 항상 같은 데이터셋을 본다.

백업이나 분석처럼 오래걸리며 읽기만 하는 질의에 요긴하다.

#### 스냅숏 격리 구현

더티 쓰기 방지를 위해 쓰기 잠금

읽는 쪽에서 쓰는쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다!

#### 다중 버전 동시성 제어

트랜잭션에서 서로 다른 시점의 디비 상태를 봐야할 수도 있기 때문에 디비가 객체의 여러 버전을 함께 유지하는 기법

포스트그레스큐엘에서는 어떻게 구현?
- 트랜잭션 아이디를 테이블에 같이 저장한다. 업데이트가 일어나면 기존데이터 삭제, 새로운 데이터를 트랜잭션 ID와 함께 저장한다.


#### 일관된 스냅샷을 보는 가시성 규칙

트랜잭션ID 기준으로 볼 수 있는것과 없는것을 정한다. (가시성 규칙)
1. 디비는 각 트랜잭션을 시작할때 그 시점에 진행중인 모든 트랜잭션의 목록을 만든다.
이 트랜잭션들이 쓴 데이터는 모두 무시된다. 데이터를 쓴 트랜잭션이 나중에 커밋되더라도 같음
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

#### 색인 관리는?

색인이 모든 버전을 가리키게하고 색인질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 한다.(트랜잭션ID 기준으로)

#### 갱신 손실 방지
동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 문제

read-modify-write 을 두 트랜잭션이 동시에 진행할 때 발생할 수 있다.

#### 해결법

1. 원자적 연산 수행 
- 객체를 읽을때 잠금을 획득해서 갱신이 적용될때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다. 커서 안정성

2. 명시적 잠금
- 애플리케이션단에서 갱신할 객체를 명시적으로 잠근다.

3. 갱신 손실 자동 감지
- 트랜잭션의 병렬 수행을 허용하고, 트랜잭션 관리자가 갱신손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하게 한다.

4. Compare-and-set
- 값을 마지막으로 읽은 후로 변경되지 않았을때만 갱신을 허용한다.
일치하지 않을경우 다시 read한다.


위에서 말한 방법들은 복제본이 없다는 가정 하에 설명한 것.

복제본이 있을경우 최신 데이터를 가진 복사본이 하나가 아닐 수 있기 때문에 추가 단계가 필요하다.
-> 쓰기가 충돌되면 여러개의 충돌버전을 유지하고 애플리케이션에게 충돌 해소를 맡긴다.



#### 쓰기 스큐와 팬텀
쓰기 스큐 
- 두 트랜잭션이 두 개의 다른 객체를 동시에 갱신했을때 애플리케이션의 조건을 만족하지 못하는 상황이 발생하는것

팬텀 
- 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
팬텀은 쓰기 스큐를 유발할 수 있다.

팬텀을 디비에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하는 것을 충돌 구체화 라고 한다.


### 직렬성
스토어드 프로시저 
- 디비 내장 함수 :
데이터를 모두 메모리에 올려놓고 쿼리를 수행한다.
네트워크 대기가 필요없고 단일 스레드 이므로 동시성 제어 오버헤드가 없어 성능이 좋다.

파티셔닝
- 스토어드 프로시저는 단일 스레드 이므로 처리량이 CPU의 코어 1개 처리 속도로 제한된다.
각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝 할 수 있다면 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있다.



#### 실제적인 직렬 실행
#### 2단계 잠금(2PL)
쓰기에 대한 독점적인 접근이 필요하다.
2PL에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막는다.
갱신 손실과 쓰기 스큐 등 모든 경쟁조건으로부터 보호해준다.

구현

- 읽기 - 공유 모드 잠금
- 쓰기 - 독점 모드 잠금
- 읽다가 쓰는 경우 공유 -> 독점 잠금으로 업그레이드

성능은 ?

동시성이 줄어들어 대기하는 시간이 많아지기 때문에 완화된 격리수준을 쓸 때보다 처리량, 응답 시간이 크게 나빠진다.

서술 잠금

공유/독점 잠금과 비슷하게 동작하지만 특정 객체가 아닌 어떤 조건에 부합하는 모든 객체를 잠근다.

아직 데이터베이스에 존재하지 않지만 미래에 추가될 수 있는 객체도 적용할 수 있다.
-> 진행중인 트랜잭션이 가진 잠금이 많으면 조건에 부합하는 잠금을 찾는데 오래 걸리기 때문에 잘 사용하지 않음

색인 범위 잠금

더 많은 객체가 부합하도록 서술 잠금을 만족하는 더 큰 범위에 색인을 기준으로 조건을 거는 것
다른 트랜잭션이 같은 객체를 수정하려고 할때, 색인의 같은 부분에 걸린 잠금을 발견하고 끝날때까지 기다린다.

#### 직렬성 스냅숏 경리(SSI)

트랜잭션이 커밋될 때 디비에 위반사항이 있는지 확인한다.(낙관적)

스냅샷 기반이기 때문에 한 트랜잭션의 모든 읽기는 같은 데이터를 본다.
스냅숏 격리 + 직렬성 충돌 감지 + 어보트 트랜잭션 결정

경쟁이 심할경우 어보트 시켜야하는 트랜잭션 비율이 높아지므로 성능이 떨어진다.

직렬성 격리 : 데이터를 읽은 뒤 수정할때 처음에 읽은 값이 아닐 수 있다.
이를 어떻게 감지할까?
1. 오래된 MVCC 객체 버전을 읽었는지 감지하기(읽기 전에 커밋되지 않은 쓰기가 발생했음)
2. 과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)

오래된 MVCC 읽기 감지하기

트랜잭션이 커밋하려고 할때 데이터베이스는 무시된 쓰기 중에 커밋된게 있는지 확인해야한다.

과거의 읽기에 영향을 미치는 쓰기 감지하기

트랜잭션이 디비에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 한다.
트랜잭션이 읽은 데이터가 더이상 최신이 아니라고 트랜잭션에 알려준다.