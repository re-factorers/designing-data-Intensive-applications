# Replication

- 복제 : 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미
- 복제가 필요한 이유 
  - Ruduce Latency
  - Increase Availability
  - Increase Read Throught



<u>복제에서 모든 어려움은 복제된 데이터의 변경 처리</u>에 있으며 이것이 이번장의 중심 내용이다. 이번 장에서는 노드 간 변경을 복제하기 위한 세 가지 인기있는 알고리즘인 single-leader, multi-leader, leaderless 복제를 살펴본다.



## Leader And Followers

데이터베이스의 복사본을 저장하는 각 노드를 replica 라고 하고, 데이터베이스의 모든 쓰기는 모든 replica에서 처리되어야 한다. 이를 위한 가장 일반적인 해결책은 **leader-based replication (active/passive, master/slave, primary/secondary)** 이다.

leader = master, primary
follower = read replica, secondary, hot standby

쓰기 요청은 리더에서만 수행하고, 읽기 요청은 리더 또는 팔로워가 수행한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 replication logs나 change stream의 일부로 팔로워에게 전송한다. 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

- Postgresql, MySQL 등의 여러 RDB와 몽고DB를 포함한 일부 비관계형 데이터 베이스에서도 사용된다.

![img](https://blog.kakaocdn.net/dn/GZxo2/btqXBWny8W2/6WME00kThdCeFSapYQzSY1/img.png)



### Synchronous VS Asynchronous Replication

replication 시스템의 중요한 세부 사항은 동기식으로 발생하는지 비동기식으로 발생하는지 여부이다. (보통 RDB에서는 사용 가능한 옵션)

![img](https://blog.kakaocdn.net/dn/8xssY/btqXFfNsjBE/lsJBELkJZnwUx17aRcy210/img.png)

**Synchronous**

- 팔로와와 리더가 일관성 있게 최신 데이터 복사본을 갖는 것을 보장 (갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신)
- 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음 (리더는 모든 쓰기를 lock하고 동기 복제 서버가 다시 사용할 수 있을 때까지 기다려야함)

**Semi-synchronous**

- 모든 팔로워가 동기식인 상황은 비현실적이므로, 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 방식
- 동기식 팔로워가 사용할 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다.
- 두 노드(리더와 하나의 동기 팔로워)에 최신 복사본이 있는 것을 보장한다.

**Asynchronous**

- 보통 리더 기반 복제는 완전히 비동기식으로 구성
- 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 쓰기는 유실됨
- 쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않음
- 그러나, 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다는 장점이 있음



### 새로운 팔로워 설정

복제 서버 수를 늘리거나 장애 노드 대체를 위해 새로운 팔로워를 설정해야 하는 경우, 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?

1. (가능하다면) 전체 DB를 잠그지 않고 리더의 DB snapshot을 일정 시점에 가져온다.
2. snapshot을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 snapshot 이후 발생한 모든 데이터 변경을 요청한다. (PostgreSQL에서는 log sequence number 기준 요청)
4. 팔로워가 snapshot 이후 데이터 변경의 backlog를 모두 처리했을때부터 리더에 발생하는 변화를 이어 처리할 수 있다.



### 노드 중단 처리

개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고, 노드 중단의 영향을 최소화하는 방법 즉, 리더 기반 복제에서 고가용성을 유지하는 방법은?



**팔로워 장애 : Catch-up recovery**

각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관하고, 장애가 발생한다면 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아내 그 이후의 데이터 변경을 업데이트 시킨다.

**리더 장애 : Failover**

리더의 장애를 처리하는 일은 까다롭다. <u>팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 장애복구(failover) 라고 한다.</u>

자동 Failover 단계

1. 리더가 장애인지 판단 : 어떤 장애인지 알 수 있는 확실한 방법이 없기 때문에 대부분 단순히 타임아웃을 사용함. 노드들끼리 서로 메시지를 주고받고 일정 시간 동안 노드가 응답하지 않으면 죽은 것으로 간주
2. 새로운 리더 선택 : election process나 controller node에 의해 이뤄진다. 가장 적합한 후보는 이전 리더의 회신 데이터 변경사항을 가진 복제 서버임
3. 새로운 리더 사용을 위해 시스템 재설정

failover시 발생할 수 있는 문제

- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다.
- 특정 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있음 (split brain)
- 리더의 죽음 판단의 적절한 타임아웃

이에 대한 쉬운 해결책은 없기 떄문에 일부 운영팀은 수동 장애 복구를 선호한다.

노드장애, 불안정한 네트워크, 복제 서버 일관성과 관련된 트레이드 오프, 지속성, 가용성, 지연시간 등의 문제는 failover시 뿐만 아니라 분산시스템에서 발생하는 근본적인 문제들이다. -> 8장에서 더 살펴본다.



### Replication logs 구현

리더 기반 복제는 내부적으로 어떻게 동작할까?

**statement-based replication**

리더는 모든 쓰기 요청(statement)를 기록하고 쓰기를 실행한 후 구문 로그를 팔로워에게 전송한다. RDB에서는 Insert, Update, Delete 구문을 팔로워에게 전달하고 각 팔로워는 이를 파싱해 실행한다. 

이 접근법은 복제가 깨질 수 있는 다양한 사례가 있기 때문에 (Now(), Rand() 사용하는 경우, 자동 증가 칼럼을 사용하는 경우 순서보장 필요 등) 일반적으로 다른 복제 방법을 선호한다.

**쓰기 전 로그 배송 (Write-ahead log (WAL) shipping)**

일반적으로 모든 쓰기는 로그에 기록하기 때문에, 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다. (PostgreSQL, Oracle 등에서 사용)

가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이고, 이때문에 복제가 저장소 엔진과 밀접하게 엮인다. 복제 프로토콜이 버전의 불일치를 허용하지 않기 때문에 업그레이할 때 중단시간이 필요하다.

**Logical (row-based) log replication**

복제 로그를 저장소 엔진 내부와 분리하기 위한 방법은 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다. 이러한 종류의 복제 로그를 논리적 로그(logical log)라고 한다.

이 방식은 하위 호환성을 더 쉽게 유지할 수 있고 외부 애플리케이션이 파싱하기 더 쉽다.

**Trigger-based replication**

트리거 기반 복제트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행된다. 

일반적으로 트리거 기반 복제에는 다른 복제 방식보다 많은 오버헤드가 있고 데이터베이스에 내장된 복제보다 버그나 제한사항이 더 많이 발생한다. 그럼에도 트리거 기반 복제는 유연성 때문에 유용하다.



## 복제 지연 문제

<u>아쉽게도 애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.</u> 이 상황은 데이터베이스에 명백하게 불일치가 발생한다. 이와 동시에 리더와 팔로워에 동일한 질의를 수행하면 모든 쓰기가 팔로워에 반영되지 않았기 때문에 서로 다른 결과를 얻을 수도 있다. <u>하지만 이런 불일치는 일시적인 상태에 불과하다. 데이터베이스에 쓰기를 멈추고 잠시 동안 기다리면 팔로워는 결국 따라잡게 되고 리더와 일치하게 된다. 이런 효과를 최종적 일관성이라 한다.</u>

최종적 일관성을 유지하는 DB에서 <u>정상적인 동작에서 리더에서 일어난 쓰기와 팔로워에서 반영 사이의 지연을 복제 지연</u>이라고 하는데, 이번 절에서는 이러한 복제 지연이 있을 때 발생할 수 있는 세 가지 사례와 해결방법을 살펴본다.

### 자신이 쓴 내용 읽기

사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있다. 이런 상황에서는 사용자가 페이지를 재로딩 했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하지만, 다른 사용자에 대해서는 보장하지 않는 자신의 쓰기 일관성이 필요하다.

### 단조 읽기

![img](https://blog.kakaocdn.net/dn/c5iSkw/btqXJWnwjuB/mUZyQooj2i0P41pOWoaCKK/img.png)

단조 읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다. (ID 해시 기반 복제 서버 선택하기 등..)

### 일관된 순서로 읽기

파티셔닝된 데이터베이스에서 발생하는 특징적인 문제. 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이 있지만 일부 애플리케이션에 대해서는 효율적이지 않다.

### 복제 지연을 위한 해결책

개발자가 복제 지연에 대한 문제를 걱정하지 않고 데이터베이스를 신뢰할 수 있도록 하는 것이 트랜잭션이 있는 이유이다. 그러나 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다. 트랜잭션이 성능과 가용성 측면에서 너무 비싸고 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장이 있다. -> 관련해서는 7장과 9장에서 더 살펴봄



## Multi-Leader Replication

단일 리더 복제 방식이 일반적이지만 여러 접근 방법이 있다. 리더 기반 복제의 주요 단점은 리더가 하나만 존재하고 모든 쓰기는 리더를 거쳐야 하기 때문에, 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다는 것이다.

쓰기를 허용하는 노드를 하나 이상 두고, 쓰기를 처리하는 각 노드는 데이터 변경을 다른 모든 노드에 전달하는 방식을 다중 리더 설정(master-master, active/active replication) 이라고 한다.

### 다중 리더 복제의 사용 사례

일반적으로는 복잡도에 비해 이점이 크지 않지만, 몇 가지 상황에서는 이 설정이 합리적이다.

**다중 데이터 센터 운영**

![img](https://blog.kakaocdn.net/dn/bndRuL/btqXHfzFFiD/Rb5fI1RMVxKv42OWRmKxQ0/img.png)

여러 다른 데이터 센터에 데이터베이스 복제 서버가 있다고 해보자(전체 데이터 센터의 내결함성을 갖추기 위해서 또는 사용자에게 지리적으로 가까이 위치하기 위해). 일반적인 리더 기반 복제 설정은 리더가 하나의 데이터 센터에 있고 모든 쓰기는 해당 데이터 센터를 거쳐야 하지만, <u>다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수 있고, 각 데이터 센터 내에는 보통 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터 센터의 리더가 다른 데이터 센터의 리더에게 변경 사항을 복제한다.</u>

다중 리더 복제에는 분명 이점이 있지만 큰 단점도 있다. <u>동일한 데이터를 다른 두개의 데이터 센터에서 동시에 변경할 수 있다 (쓰기 충돌).</u> 이 외에도 자동 증가 키, 트리거, 무결성 제약 등 문제의 소지가 많다. 이런 이유로 <u>다중 리더 복제는 가능하면 피해야 하는 위험한 영역으로 간주되곤한다.</u>

- 오프라인 작업을 하는 클라이언트 (ex 캘린더 앱)
- 협업 편집



### 쓰기 충돌 다루기

각 사용자가 같은 데이터를 변경하는 경우 각 변경이 로컬 리더에서 성공적으로 적용하지만 변경을 비동기로 복제할 때 충돌이 감지될 수 있다.

![img](https://blog.kakaocdn.net/dn/c7LUFt/btq42AC1sPk/07n6OXhoDFBCCObb50HE21/img.png)

**동기 대 비동기 충돌 감지**

단일 리더 데이터베이스에서 첫 번쨰 쓰기가 완료될 때까지 두 번째 쓰기를 차단해 기다리게하거나 두 번째 쓰기 트랜잭션을 중단해 사용자가 쓰기를 재시도하게 한다. 반면, 다중 리더 설정에서는 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지한다. 충돌 감지를 동기식으로 만들 수는 있지만, 이는 다중 리더 복제의 주요 장점을 잃는다.

**충돌 회피**

제일 간단한 전략은 충돌을 피하는 것이다. 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다. 이 방법은 한 사용자의 관점에서 보면 구성은 기본적으로 단일 리더다.

**일관된 상태 수렴**

다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다. 모든 복제 서버가 최종적으로는 동일하다는 사실을 보장하기 위해 데이터베이스는 수렴(covergent) 방식으로 충돌을 해소해야 한다.

- 각 쓰기에 고유 ID (타임스탬프 등) 부여
- 각 복제 서버에 고유 ID 부여
- 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존



### 다중 리더 복제 토폴로지

복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명한다.

![img](https://blog.kakaocdn.net/dn/bnKnaq/btq40RksH2C/5G7OUxoUj4wJ8CvrwsNzdk/img.png)

1. 전체 연결(all-to-all)
   - 모든 리더가 각자의 쓰기를 다른 모든 리더에서 전송한다.
2. 원형 토폴로지(circular topology)
   - 각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기를 다른 한 노드에 전달한다.
   - MySQL에서 기본적으로 사용
3. 별 모양 토폴로지(star topology)
   - 지정된 루트 노드가 하나가 다른 모든 노드에 쓰기를 전달한다.

원형 토폴로지와 별 모양 토폴로지의 단점은 하나의 노드에 장애가 발생하면 장애가 다른 노드 간 복제 메시지 흐름에 방해를 준다는 것이다. 반면 전체 연결 토폴로지는 일부 네트워크 연결이 다른 연결보다 빠르다면 일부 복제 메시지가 다른 메시지를 추월할 수 있는데, 이런 이벤트를 올바르게 정렬하기 위해 version vector라고 하는 기법을 사용할 수 있다.



## Leaderless Replication

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다. 아마존이 내부 다이나모 시스템에서 사용한 후 유명해졌다. 이런 종류의 데이터베이스를 다이나모 스타일이라 한다.

일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 코디네이터 노드(coordinator node)가 클라이언트를 대신해 이를 수행하기도 한다.

### 노드가 다운됐을 때 데이터베이스에 쓰기

리더 없는 설정에서는 장애 복구가 필요하지 않다. 클라이언트가 쓰기를 세 개의 복제 서버에 병렬로 전송하고, 세 개의 복제 서버 중 하나의 복제 서버가 쓰기를 놓쳤다. 이때 세 개의 복제 서버 중 두 개의 복제 서버가 쓰기를 확인하면 충분하다고 가정했을 때, 클라이언트는 복제 서버 중 하나가 쓰기를 놓친 사실을 단순히 무시한다.

복제 서버가 복구 되었을 때, 장애가 났던 복제 서버에서는 outdated된 값을 얻을 수 있다. 이를 해결 하기 위해서는 클라이언트가 데이터베이스에서 읽을 때 하나의 복제 서버로 요청을 보내지 않고 읽기 요청을 병렬로 여러 노드에 전송한다. 한 노드에서는 최신 값을 받고 다른 노드에서는 오래된 값을 받을 때, 버전 숫자를 사용해 어떤 값이 최신 내용인지 결정한다.

**읽기 복구와 안티 엔트로피**

사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 복구하는 법

1. 읽기 복구
   - 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다. 클라이언트는 오래된 값을 인지하고 해당 복제 서버에 새로운 값을 다시 기록한다. 이 방법은 값을 자주 읽는 상황에 적합하다.
2. 안티 엔트로피 처리
   - 일부 데이터스토어는 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.
   - 리더 기반 복제에서의 복제 로그와 달리 이 안티 엔트로피 처리는 특정 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

**읽기와 쓰기를 위한 정족수**

리더없는 복제에서 N개의 복제 서버 중 w개에서만 쓰기를 처리해도 성공한 것으로 간주하는 기준은 어떻게 될까?

- 일반적으로 w = r = (n+1) /2 로 설정한다.



### 동시 쓰기 감지

다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키를 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생한다.

**최종 쓰기 승리(동기 쓰기 버리기)**

각 복제본이 가진 예전 값을 버리고 가장 최신 값으로 덮어쓴다. 어떤 쓰기가 최신인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복제본은 최종적으로 동일한 값으로 수렴한다. (타임스탬프 이용 등..)

**이전 발생 관계와 동시성**

한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심이다. 두 작업이 동시에 수행됐는지 여부를 확인하는 알고리즘은 아래와 같다.

- 서버가 모든 키에 대한 버전 번호를 유지하고, 키를 기록할 때마다 버전 번호를 증가시킨다. 기록한 값은 새로운 버전 번호를 가지고 저장된다.
- 클라이언트가 키를 읽을 때는 서버는 최신 버전 뿐만 아니라 덮어쓰지 않은 모든 값을 반환한다. 클라이언트는 쓰기 전에 키를 읽어야 한다.
- 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고, 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다. (쓰기 요청의 응답은 읽기 요청과 같을 수 있다. 쓰기 요청이 현재 모든 값을 반환하기 때문이다.)
- 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다. 하지만 이보다 높은 버전 번호의 모든 값은 유지해야 한다. 이 값들은 유입된 쓰기과 동시에 발생했기 때문이다.

**동시에 쓴 값 병합**

여러 작업이 동시에 발생하면 클라리언트는 동시에 쓴 값을 합쳐 정리해야 한다. 이를 병합하는 가장 합리적인 접근 방법은 합집합을 취하는 것이다.





## 정리

복제는 다양한 용도로 사용할 수 있다

- 고가용성
- 연결이 끊긴 작업
- 지연 시간
- 확장성

복제에 대한 세 가지 주요 접근 방식

- 단일 리더 복제
- 다중 리더 복제
- 리더 없는 복제

단일 리더 복제는 이해하기 쉽고 충돌 해소에 대한 우려가 없어서 널리 사용된다. 다중 리더 복제나 리더없는 복제는 결함 노드, 네트워크 중단, 지연 시간 급증이 있는 상황에서 견고하지만 설명하기 어렵고 일관성이 거의 보장되지 않는다는 점이 단점이다.



복제는 동기 또는 비동기로 이뤄진다. 이는 결함이 있을 때 시스템 작동에 중요한 영향을 미친다. 비동기 복제는 시스템이 원활히 동작할 때는 빠르지만, 복제 지연이 증가하고 서버 장애가 발생하면 어떤 일이 일어났는지 파악하는 작업이 중요하다.